# Computational Thinking with C



#### 컴퓨터공학 사고력

주어진 문제를 분석, 이해하고 문제의 해결 방법을 컴퓨터 공학의 원리를 적용하여 알고리즘을 도출하고 컴퓨터가 이해하는 프로그래밍 언어로 제시하는 사고능력



#### 컴퓨터 공학적 문제 해결과정

1. 문제 이해 및 분석

2. 컴퓨터 공학적 원리 적용

3. 문제 해결 방법의 설계(알고리즘 설계)

   - 의사코드(pseudo code) 

     일반적인 언어로 코드를 흉내 내어 알고리즘을 써놓은 코드

     >a 변수에 10을 넣는다.
     >
     >b 변수에 20을 넣는다.
     >
     >sum 변수에 a와 b를 더한 값을 넣는다.
     >
     >sum을 출력한다.

   - 순서도(flow chart)

     여러 종류의 상자와 화살표를 이용해 명령의 순서를 보여주는 도형

4. 문제 해결 방법의 프로그래밍(알고리즘 구현, 코딩)

5. 결과검토





#### 하드웨어와 소프트웨어

- 하드웨어 

  - 컴퓨터를 구성하는 물리적인 장치(device)

- 소프트웨어

  - 컴퓨터가 수행할 작업을 지시하는 명령어들의 집합(문서포함)
  - 시스템 소프트웨어(운영체제, 컴파일러)
  - 응용 소프트웨어(워드 프로세서, 게임)

   

#### 컴퓨터의 자료표현

- 자료 표현 원리
  - 2진수(binary) 체계 사용
  - 전기신호: ON(1), OFF(0)

- 비트(bit)
  - Binary Digit, 0 또는 1 두개 정보를 표한하는 정보의 최소 단위
- 바이트(byte)
  - 연속된 8개의 비트 (256개), 문자를 표현하는 단위
  - kb = 2^10^, mb = 2^20^, gb = 2^30^ ,...

#### 

#### 컴퓨터와 사람의 의사소통

- 문자 코드

  - N비트의 조합에 일정한 문자를 할당해 지정한 것을 문자 코드
  - 국제 표준인 문자 코드는 아스키코드, 유니코드

- 아스키코드(ASCII)

  - American Standard Code for Information Interchange
  - 국제적인 표준으로 사용하는 문자 코드체계로서 7비트를 사용해 128개의 문자, 숫자, 특수문자 코드를 규정
  - 대문자 A의 코드는 1000001(65)


#### 프로그래밍 언어

사람과 컴퓨터가 의사소통을 하기 위해 만든 언어로 사람이 컴퓨터에세 지시할 명령어를 기술하기 위해 만들어진 언어

- low level - 기계어, 어셈블리어
- high level - C, C++, Java, Python,.. 



#### 컴파일러와 어셈블러

- 컴파일러 : 고급언어로 작성된 프로그램을 기계어로 번역

  > 컴파일(compile) : 소스의 문법을 분석해 기계어로 번역 
  >
  >  빌드(build) : 번역된 것과 그외 잡다한걸 모아서 실행 가능한 파일로 만듦(=compile + 그외)

- 어셈블러 : 어셈블리언어로 작성된 프로그램을 기계어로 번역


#### 운영체제와 프로그래밍 언어

![os-pl-history](/jpg/pl-history.jpg)

- C  (1972) : 데니스 리치
  - 유닉스 운영체제 작성을 위해 시스템 프로그래밍 언어로 설계된 언어
  - 컴파일러나 수많은 소프트웨어 도구들도 C언어로 개발
  - 풍부한 연산자와 데이터 형을 갖고 있기 때문에 범용 프로그래밍 언어로서 널리 보급되었으며, 응용 소프트웨어의 개발에 널리 이용

- C++ (1983)
  - 객체지향 프로그래밍을 지원하기 위해 C언어가 가지는 장점을 그대로 계승하면서 객체의 상속성 등의 개념을 추가한 효과적인 언어
- JAVA (1992)
  - 자바의 시초는 1992년 미국의 SUN 사에서 가전 제품들을 제어하기 위한 언어에서부터 비록됨
  - 객체지향 프로그래밍 언어
  - 분산 네트워크상에서의 프로그래밍이 용이
- Python (1991) : Guido van Rossum 
  - 플랫폼 독립적
  - 인터프리터 언어
    - 컴파일러 언어와는 다르게 한줄 한줄씩 읽어 기계어로 번역 
  - 동적 타이핑 언어
    - C, C++과 다르게 사용할 변수의 타입을 동적으로 정해서 저장해줌
  - AI 프로그래밍을 위한 많은 라이브러리 제공
  - 처음 C언어로 개발



#### 컴퓨터 프로그램

- 프로그램
  - 컴퓨터에게 어떤일의 수행을 지시하는 명령어들의 집합 ( 실행파일, hello.exe )

- 프로그램 개발에 필요한 도구
  - 에디터(editor) : 코드 작성
  - 컴파일러(compiler) : 에디터로 작성된 소스코드를 기계어로 번역해주는 프로그램(turbo c, gcc)
    - 다양한 운영체제에서 C 컴파일러 사용가능
  - 링커(linker) : 번역된 여러 목적코드를 하나로 묶어주는 역할
    - 목적코드 : 번역된 명령어(기계어)
  - 디버거(debugger) : 프로그램 오류를 수정하는 도구로 명령을 줄 단위로 실행하고 결과 확인이 가능
  - 위의 기능을 모두 제공하는 프로그램이 통합개발환경(IDE)





#### 실행파일 생성 및 실행 과정

```mermaid
 graph LR
  	A[소스파일-hello.c] -->|컴파일러| B(목적파일-hello.obj)
 	B -->|링커| C(실행파일-hello.exe)
 	C -->|로더| D(메모리)
 	D -->|로더| E(실행)
```

> 전처리기 > 컴파일러 > 어셈블러 > 링커

- GCC 하나로 위의 과정을 모두 진행 시켜 소스 파일을 실행 파일로 생성 시켜줌
- C preprocessor는 소스 파일의 주석 제거 및 define을 치환하는 기능 등을 함
- C Compiler는 전처리기를 거친 소스 파일을 어셈 파일로 변환
- Assembler는 어셈파일을 오브젝트 파일로 변환
- Linker는 오브젝트 파일들을 묶어서 실행 파일로 변환





### C 프로그램 구조



#### 모듈(module)

- 큰 문제를 기능별 작은 단위로 나눈 것

- 독립적으로 수행할 수 있는 프로그램 단위

  > 데이터 입력/처리/출력 



#### 구조

표준 입출력 함수를 사용하기 위해 <stdio.h> 헤더 파일을 소스코드에 포함시킴

- 입력함수 : scanf()
- 출력함수 : printf()

헤더파일에는 일반적으로 함수의 원형이 들어있다.

```c
// #은 전처리 지시자로 컴파일러가 기계어로 바꾸기 전에 처리해라라는 기호
// 기계어로 바꾸기전에 stdio라는 header파일(표준입출력에 관한 함수들이 모여있는 헤더파일)을 소스코드에 포함시켜줘

#inclue <stdio.h>

int main(void) { //int는 return 의 타입
    printf("Hello, world!\n");
    return 0; //return은 나를 호출했던 쪽으로 이 값을 넣어서 돌아가줘 (1개 값만 리턴가능)
}

```



#### 함수(function) = 모듈, 메소드(C++, Java)

독립적으로 수행할 수 있는 프로그램 단위

```c
/* 주석 */
#include<stdio.h>

//함수 밖 명령
int add(int x, int y);

//메인 함수: C프로그램은 main함수부터 시작해 main함수에서 끝남(사용자 정의 함수라 할 수 있다)
int main(void) {                
    int a, b, sum;				
    scanf("%d %d", &a, &b);		
    sum = add(a,b);				
    printf("%d", sum);			
    return 0;					
}

//사용자 정의 함수
int add(int x, int y)			
{
    return x + y;				
}

// 시스템 라이브러리 함수 - 많이 사용하는 기능의 함수들을 시스템에서 미리 만들어 놓고 사용자가 사용할 수 있도록 제공하는 함수 
// 예: 입출력 함수(scanf(), printf())

```



#### 변수와 상수

- 변수 : 데이터를 메모리에 저장하는 공간, 변수명은 자료값을 저장하는 저장 장소의 이름
  - 지역변수 - 함수 지역 안에서 선언된 변수는 다른 변수에서 그 내용을 보거나 수정 할 수 없음

- 예약어
- 식별자 - 사용자가 만든 이름 (변수명, 함수명 등)
- 연산자(operator)
  - ex) sizeof - 저장공간의 크기를 알 수 있는 연산자
- 표현식(expression) - 항상 평가값을 가짐
- 문장(statement) - 하나의 처리 단위는 반드시 세미콜론으로 끝내야함. 컴파일러에게 처리 단위를 알려주는 역할(복합문은 {}사용)
- 대입문(assignment statement) - 대입연산자(=)는 오른쪽에 있는 표현식의 평가값을 왼쪽 변수에 저장



#### 데이터타입

데이터 처리를 하기 위해서는 데이터를 저장(메모리에)해야함

데이터를 종류에 따라 분류하여 적절한 크기의 공간에 저장하기 위해 데이터 타입이 필요

- 기본 자료형 : int, char, float, ...
- 유도 자료형(derived type) : 배열, 구조체, 공용체





#### 전처리기(preprocessor)와 입출력 함수

- 전처리기는 컴파일러가 프로그래밍 언어를 기계어로 바꾸기 전에 처리해야할 명령을 먼저 수행하는것
  - **#include** - 다양한 라이브러리를 작업 중인 소스파일에서 사용할 수 있도록 헤더 파일을 포함
  - **#define** - 컴파일 전에 소스파일의 문자열1을 문자열2로 치환 (#define PI 3.141592)

- printf 함수

  - 변수값 출력

    ```c
    int a, b:
    float c;
    printf("%d %f %d\n", a, c, b);
    ```

  - 형식지정자

    ```plain
    %d //정수를 10진수로 출력
    %f //소수점이 있는 실수로 출력
    %c //문자 형태로 출력
    %s //문자열 형태로 출력
    ```

- scanf 함수

  - 키보드로부터 입력된 데이터를 지정된 형식으로 변환하여 변수에 저장

  - 임의의 개수로 입력 받을 수 있음

    ```c
    int age;
    float weight;
    scanf("%d %f", &age, &weight);//&는 주소 연산자
    ```


#### 사용자 정의 함수

함수는 독립적으로 수행하는 프로그램 단위, 반복적으로수행되는 기능을 함수로 만들어 호출

```c
//리턴타입 함수이름 (매개변수 리스트)
int add (int x, int y)
{
    int sum;
    sum = x + y;
    return sum;
}
```

> 컴파일 할 때마다 저장공간(변수)의 주소 값은 달라진다.



#### 함수와 매개변수

- 매개변수 없는 함수

  ```c
  //함수 원형
  void hello(void)
  	
      void main() {
      hello(); //함수호출
  }
  //함수 정의
  void hello() {
      printf("Hello C!");
      return;
  }
  ```


- 매개변수 있는 함수
  - 지역변수
  - 함수 호출 방법: call by value



#### 함수 호출 방법

두 개의 변수 값을 서로 바꾸려면?

```c
temp = a;
a = b;
b = temp;
```

다른 함수를 통해서 두개의 변수 값을 서로 바꾸려면?

main 함수에 있는 변수 두 개의 값을 정렬을 위해 서로 바꾸고 싶은데 자주 사용되는 기능이므로 함수를 만들어서 호출하고 싶다면?

##### 문제해결하기

main 안에서 변수 값을 temp 변수를 사용해 서로 변경하면 바뀌지만 다른 함수로 두 변수 값을 call by value 보내서 바꾼다면 지역변수 특성상 main 함수 영역에 있는 변수 값을 두개 모두 바꿀수 없음 (return 값은 1개 값만 가지고 올 수 있으므로)

##### 그렇다면 다른 방법을 찾아보자

- 주소에 의한 호출 (Call by address)

  main 함수에 있는 변수의 주소값을 가지고 swap() 함수를 호출하면 swap() 함수에서 main 함수의 변수 값을 바꿀 수 있음(포인터 변수사용)

  바꾸기 위해서는 역참조 연산자를 사용해야 함

- 포인터
  - 포인터 변수 : 주소를 값으로 가지는 변수. 주소값을 저장하기 위해서는 포인터 변수가 필요함
  - 포인터 변수 선언 : `int *p`, `int *q`
  - 포인터 변수는 주소 값만 값으로 가질 수 있음
  - `int *p = &a` / `P = &a`

- 역참조 연산자 : 포인터 변수 선언 후에 문장 중에 포인터 변수 앞에 * 가오면 (*p) 포인터 변수가 가리키는 main 변수의 값을 변경할 수 있음

  > *의 두가지 용법 
  >
  > 1. 포인터 변수 선언
  >
  > 2. 역참조 연산자

![call-by-address](/jpg/call-by-address.jpg)



#### 연산자(operator)

사칙, 관계, 논리 연산자 기호와 같이 이미 정의된 연산을 수행하는 기호나 키워드를 의미

- 피연산자(operand) : 연산에 참여하는 변수나 값을 피연산자

- 우선순위

  ```
  1. () [] . -> a++ a--
  2. ++a -a ! sizeof() -(단항) +(단항) &(주소) *(역참조)
  3. * / %
  4. + -
  5. < > <= >=
  6. == !=
  7. &&
  8. ||
  9. ? :
  10. = += -= *= /= %=
  11. ,
  ```



#### 조건문과 반복문, 분기문

- if, switch~case
- for, while, do~while
- break, continue, goto



#### 파일입출력

데이터의 모임으로 보조기억장치에 저장된 것

##### 처리순서

1. 파일 연결(input.txt, output.txt)

   파일의 주소를 저장할 수 있는 파일 포인터 변수 선언

   `FILE* inData`, `outData`

2. 파일 열기 - `fopen()`

3. 파일의 데이터 읽어오기 - `fscanf()`
4. 읽어온 데이터로 원하는 결과 처리
5. 파일 닫기 - `fclose()`



#### 배열과 구조체

- 배열
  - a == &a[0] //배열 시작 주소
  - a+1 == &a[1] // a[1]원소의 주소
  - \*(a+2) = 70; //주소에 역참조연산자 이용해 원소값 변경 가능

- 사용자 정의 자료형 

  - 구조체(struct) : 동일한 자료형의 데이터가 여러 개 필요한 경우 배열에 사용해 처리할 수 있지만 성적 처리와 같이 학번, 점수, 학점 등 서로 다른 자료형을 가진 데이터를 함께 저장하고 처리하기 위해서는 새로운 자료형이 필요함

  - 구조체 정의: 다양한 자료형의 연관된 데이터를 묶어서 선언할 수 있도록 사용자 정의 자료형을 만드는것.

    > 템플릿과 같은 역할을 하며, 구조체 정의는 메모리에 변수를 생성하지 않음

    ```c
    struct stu {
        int ID;
        float kor, eng, math;
        float avg;
        char grade;
    };
    
    struct stu s1 = {10000, 85, 98, 90}; //구조체 변수 선언
    typedef struct stu stu; //타입이름 변경  
    
    s1.ID = 10001;
    s1.kor = 90.5; //. 연산자를 사용하여 구조체 멤버에 접근
    ```





